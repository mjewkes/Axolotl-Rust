/// Library Abstraction for HMAC functionality

//  Re-export MacResult so it is available when this Mod is imported.
//  if backing library Changes this Struct will have to be reimplemented for timing Safety
pub use crypto::mac::MacResult;

use crypto::hmac::Hmac as rc_Hmac;
use crypto::sha2::Sha256;
use crypto::mac::Mac;

pub struct HmacSha256{
    context : rc_Hmac<Sha256>,
}

impl HmacSha256 {
    pub fn new(key: &[u8]) -> HmacSha256 {
        return HmacSha256{context: rc_Hmac::new(Sha256::new(), key)};
    }

    pub fn input(&mut self,data : &[u8]){
        self.context.input(data);
    } 

    pub fn result(&mut self) -> MacResult {
        return self.context.result();
    }
}

pub fn truncate_mac_result(mac : MacResult, length : usize) -> MacResult {
    MacResult::new(&mac.code()[..length])
}

pub fn hmac_compare_prefix(expected : MacResult, value : &[u8]) -> bool {
    let expected_bytes = expected.code();
    let value_len = value.len();
    if expected_bytes.len() < value_len {
        return false;
    }

    let expected_truncated = MacResult::new(&expected_bytes[..value_len]);
    let value_mac = MacResult::new(value);
    return expected_truncated == value_mac;
}

#[cfg(test)]
mod tests {
    use super::*;

     #[test]
    fn hmac_sha256_rfc4231_1() {
        let key =  [0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
                    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B];

        let data = [0x48, 0x69, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65];

        let expected = [0xB0, 0x34, 0x4C, 0x61, 0xD8, 0xDB, 0x38, 0x53, 0x5C, 0xA8, 
                        0xAF, 0xCE, 0xAF, 0x0B, 0xF1, 0x2B, 0x88, 0x1D, 0xC2, 0x00, 
                        0xC9, 0x83, 0x3D, 0xA7, 0x26, 0xE9, 0x37, 0x6C, 0x2E, 0x32, 
                        0xCF, 0xF7];

        let mut  hmac = HmacSha256::new(&key);
        hmac.input(&data);
        let r = hmac.result();

        assert!(hmac_compare_prefix(r,&expected));
    }

    #[test]
    fn hmac_sha256_rfc4231_2() {
        let key = [0x4A, 0x65, 0x66, 0x65];

        let data = [0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x79, 0x61, 
                    0x20, 0x77, 0x61, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 
                    0x6E, 0x6F, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x3F];

        let expected = [0x5B, 0xDC, 0xC1, 0x46, 0xBF, 0x60, 0x75, 0x4E, 0x6A, 0x04, 
                        0x24, 0x26, 0x08, 0x95, 0x75, 0xC7, 0x5A, 0x00, 0x3F, 0x08, 
                        0x9D, 0x27, 0x39, 0x83, 0x9D, 0xEC, 0x58, 0xB9, 0x64, 0xEC, 
                        0x38, 0x43];

        let mut hmac = HmacSha256::new(&key);
        hmac.input(&data);
        let r = hmac.result();

        assert!(hmac_compare_prefix(r, &expected));
    }
    #[test]
    fn hmac_sha256_rfc4231_3() {
        let key = [ 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
                    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA];

        let data = [0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 
                    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 
                    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 
                    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 
                    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD];
                    
        let expected = [0x77, 0x3E, 0xA9, 0x1E, 0x36, 0x80, 0x0E, 0x46, 0x85, 0x4D, 
                        0xB8, 0xEB, 0xD0, 0x91, 0x81, 0xA7, 0x29, 0x59, 0x09, 0x8B, 
                        0x3E, 0xF8, 0xC1, 0x22, 0xD9, 0x63, 0x55, 0x14, 0xCE, 0xD5, 
                        0x65, 0xFE];

        let mut hmac = HmacSha256::new(&key);
        hmac.input(&data);
        let r = hmac.result();

        assert!(hmac_compare_prefix(r, &expected));
    }
}