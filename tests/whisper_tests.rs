extern crate protobuf;
extern crate rand;
extern crate rustc_serialize;

mod whisper_protocol;

use rand::{chacha,Rng};

use whisper_protocol::{axolotl,Axolotl,AxolotlState,ReceiveError};
use whisper_protocol::crypto_wrappers::curve25519::{self,PublicKey,PrivateKey};
use whisper_protocol::text_secure_v3::{KeyPair,PlainText,TextSecureV3,TransportPacket};

#[test]
fn dynamic_roundtrip_echo(){
    let ref axolotl_impl = TextSecureV3;
    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);

    let msg = PlainText::from_vec("We take care of each other, so we can be dangerous together.".to_string().into_bytes());

    for __ in 0..10 {

        let bytes       = encrypt_and_serialze(axolotl_impl,alice,msg.clone());
        let plaintext   = deserialize_and_decrypt(axolotl_impl, bob, &bytes[..]).ok().unwrap();
        assert_eq!(msg.0 , plaintext.0);

        let bytes       = encrypt_and_serialze(axolotl_impl,bob,plaintext);
        let reply       = deserialize_and_decrypt(axolotl_impl,alice,&bytes[..]).ok().unwrap();
        assert_eq!(msg.0,reply.0);
    }
}

#[test]
fn mac_fail(){
    let ref axolotl_impl = TextSecureV3;
    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);

    let msg = PlainText::from_vec("We take care of each other, so we can be dangerous together.".to_string().into_bytes());

    let (mut packet,mut mac) = alice.encrypt(axolotl_impl, msg.clone()).unwrap();
    mac[7] = mac[7] ^ 1<<7;
    packet.set_mac(mac);
   
    let result = deserialize_and_decrypt(axolotl_impl, bob, &packet.to_vec()[..]);
    assert!(result.is_err());

    let (mut packet,mut mac) = alice.encrypt(axolotl_impl, msg).unwrap();
    mac[0] = mac[0] ^ 1<<0;
    packet.set_mac(mac);
   
    let result = deserialize_and_decrypt(axolotl_impl, bob, &packet.to_vec()[..]);
    assert!(result.is_err());
}

#[test]
fn out_of_order_multi_flight() {
    let ref axolotl_impl = TextSecureV3;
    let mut shuffler = chacha::ChaChaRng::new_unseeded();
    let mut a2b_packet_queue : Vec<(Vec<u8>,PlainText)> = Vec::<(Vec<u8>,PlainText) >::new();
    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);

    let base_string = "We take care of each other, so we can be dangerous together.".to_string();

    for i in 0..25 {
        let plaintext = PlainText::from_vec( (base_string.clone() + &i.to_string()).into_bytes());
        let packet     = encrypt_and_serialze(axolotl_impl,alice,plaintext.clone());
        a2b_packet_queue.push((packet,plaintext) );
    }

    shuffler.shuffle(&mut a2b_packet_queue[..]);

    for (packet,expected) in a2b_packet_queue {
        let plaintext = deserialize_and_decrypt(axolotl_impl, bob, &packet[..]).ok().unwrap();
        assert_eq!(expected.0 , plaintext.0);
    }
}

#[test]
fn stale_skipped_message() {
    let ref axolotl_impl = TextSecureV3;
    let chain_limit_count = 5;

    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);
    let msg = PlainText::from_vec("We take care of each other, so we can be dangerous together.".to_string().into_bytes());
    let lost_msg = encrypt_and_serialze(axolotl_impl,bob,msg.clone());
    
    for __ in 0.. chain_limit_count+1 {
        let bytes       = encrypt_and_serialze(axolotl_impl,alice,msg.clone());
        let plaintext   = deserialize_and_decrypt(axolotl_impl, bob, &bytes[..]).ok().unwrap();
        assert_eq!(msg.0 , plaintext.0);

        let bytes       = encrypt_and_serialze(axolotl_impl,bob,plaintext);
        let reply       = deserialize_and_decrypt(axolotl_impl,alice,&bytes[..]).ok().unwrap();
        assert_eq!(msg.0,reply.0);
    }

    let result = deserialize_and_decrypt(axolotl_impl, alice, &lost_msg[..]);
    assert!(result.is_err());
}

#[test]
fn bob_first_message() {
    let ref axolotl_impl = TextSecureV3;

    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);
    let msg = PlainText::from_vec("We take care of each other, so we can be dangerous together.".to_string().into_bytes());

    let bytes       = encrypt_and_serialze(axolotl_impl,bob,msg.clone());
    let plaintext   = deserialize_and_decrypt(axolotl_impl, alice, &bytes[..]).ok().unwrap();
    assert_eq!(msg.0 , plaintext.0);

    let bytes       = encrypt_and_serialze(axolotl_impl,alice,plaintext);
    let reply       = deserialize_and_decrypt(axolotl_impl,bob,&bytes[..]).ok().unwrap();
    assert_eq!(msg.0,reply.0); 
}

#[test]
fn short_message() {
    let ref axolotl_impl = TextSecureV3;
    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);
    let msg = PlainText::from_vec("".to_string().into_bytes());

    let bytes       = encrypt_and_serialze(axolotl_impl,alice,msg.clone());
    let plaintext   = deserialize_and_decrypt(axolotl_impl, bob, &bytes[..]).ok().unwrap();
    assert_eq!(msg.0 , plaintext.0);
}

#[test]
fn long_message() {
    let ref axolotl_impl = TextSecureV3;
    let mut rng = chacha::ChaChaRng::new_unseeded();
    let msg_size = 2^25+1;

    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);
    let msg = PlainText::from_vec(rng.gen_iter::<u8>().take(msg_size).collect::<Vec<u8>>());

    let bytes       = encrypt_and_serialze(axolotl_impl,alice,msg.clone());
    let plaintext   = deserialize_and_decrypt(axolotl_impl, bob, &bytes[..]).ok().unwrap();
    assert_eq!(msg.0 , plaintext.0);
}

#[test]
fn repeat_message() {
    let ref axolotl_impl = TextSecureV3;

    let (ref mut alice, ref mut bob ) = init_dynamic_axolotl_states(axolotl_impl);
    let msg = PlainText::from_vec("We take care of each other, so we can be dangerous together.".to_string().into_bytes());

    let bytes = encrypt_and_serialze(axolotl_impl,alice,msg.clone());
    let __    = deserialize_and_decrypt(axolotl_impl, bob, &bytes.clone()[..]).ok().unwrap();

    let result    = deserialize_and_decrypt(axolotl_impl, bob, &bytes.clone()[..]);

    assert!(result.is_err());
}

struct TestCase {
    alice_id_pub  : [u8;33],
    alice_id_priv  : [u8;32],
    alice_base_pub  : [u8;33],
    alice_base_priv  : [u8;32], 
    bob_id_pub  : [u8;33],
    bob_id_priv  : [u8;32],
    bob_base_pub  : [u8;33],
    bob_base_priv  : [u8;32],
    bob_ephemeral_pub  : [u8;33],
    bob_ephemeral_priv  : [u8;32],
    alice_send_ratchet_priv :[u8; 32],
    alice_send_ratchet_pub : [u8;33],
    a2b_whispermsg  : Vec<u8>,
    known_plaintext : Vec<u8>,
}

/// Test Vectors Exported from Libaxolotl-java version 1.3.4
fn interop_tests() -> Vec<TestCase> {
    vec![
        TestCase{
            alice_id_pub  : [0x05, 0x24, 0xE6, 0x1F, 0x1E, 0x0F, 0xB0, 0x18, 0x6B, 0xF9, 0x57, 0xEA, 0xB9, 0x26, 0xD5, 0x35, 0xF6, 0xDE, 0x86, 0xAD, 0x5D, 0x8B, 0x0C, 0x67, 0x23, 0xCA, 0x0D, 0x73, 0xEF, 0xF6, 0xAE, 0x4F, 0x28],
            alice_id_priv  : [0x88, 0xF9, 0x64, 0x15, 0xC2, 0xC0, 0xA2, 0x26, 0xC6, 0xEA, 0xED, 0x02, 0x0A, 0xA9, 0xC6, 0x18, 0x5A, 0x73, 0xE8, 0xCC, 0x3F, 0x20, 0xA8, 0xC5, 0x8D, 0xE9, 0xC6, 0x31, 0xBC, 0xAC, 0xCF, 0x6D],
            alice_base_pub  : [0x05, 0xEB, 0x5B, 0x60, 0x88, 0x5E, 0xA9, 0xFE, 0xE8, 0x83, 0x2B, 0x65, 0xE3, 0x19, 0x54, 0xF8, 0xC9, 0xB8, 0xD8, 0x88, 0xA3, 0xD9, 0x2F, 0xF9, 0x13, 0x36, 0x49, 0xDF, 0x31, 0xB7, 0xC1, 0xB4, 0x59],
            alice_base_priv  : [0xB8, 0xCD, 0x9A, 0xD9, 0xA7, 0x9E, 0x21, 0x38, 0x71, 0xC9, 0x63, 0xFF, 0x0F, 0x41, 0xC5, 0xA9, 0xFF, 0xA3, 0x6D, 0x0A, 0x2A, 0x5D, 0xFB, 0x80, 0xF1, 0x80, 0x6F, 0x69, 0xA8, 0x3F, 0xE8, 0x45],
            bob_id_pub  : [0x05, 0x8D, 0xE9, 0x5B, 0x33, 0xB7, 0x88, 0xAA, 0x88, 0xA2, 0x56, 0x85, 0x1D, 0x08, 0x2C, 0xE3, 0xBC, 0xA9, 0x54, 0x84, 0x5C, 0x22, 0x1D, 0xE1, 0xD8, 0xF4, 0x4B, 0x60, 0x32, 0x75, 0x1B, 0x5C, 0x78],
            bob_id_priv  : [0xA8, 0xF9, 0xAD, 0x86, 0x07, 0xCF, 0xB1, 0x7A, 0x77, 0x88, 0x83, 0x15, 0xDB, 0x24, 0xF7, 0x3D, 0x0F, 0xF5, 0x12, 0x59, 0xC3, 0x11, 0xCF, 0xDE, 0x66, 0x87, 0xEE, 0xB4, 0xF5, 0x2B, 0x61, 0x70],
            bob_base_pub  : [0x05, 0x6F, 0x55, 0x84, 0xCE, 0xAF, 0xC9, 0x25, 0xB9, 0x5D, 0x4F, 0xDA, 0x93, 0xDF, 0x8E, 0x7C, 0xC8, 0x71, 0xDE, 0xC1, 0x66, 0x23, 0xFD, 0xBA, 0x71, 0xBF, 0x5D, 0xCC, 0x37, 0xE3, 0x97, 0x94, 0x31],
            bob_base_priv  : [0x78, 0xB4, 0x9B, 0x89, 0xC8, 0xFC, 0x12, 0x91, 0xDA, 0x22, 0x93, 0x95, 0x3F, 0xF3, 0xAA, 0x1B, 0x43, 0x0C, 0x8A, 0xEA, 0xF5, 0x07, 0x4D, 0xA5, 0xAF, 0x5F, 0x19, 0x3A, 0x70, 0x62, 0x8D, 0x5C],
            bob_ephemeral_pub  : [0x05, 0x6F, 0x55, 0x84, 0xCE, 0xAF, 0xC9, 0x25, 0xB9, 0x5D, 0x4F, 0xDA, 0x93, 0xDF, 0x8E, 0x7C, 0xC8, 0x71, 0xDE, 0xC1, 0x66, 0x23, 0xFD, 0xBA, 0x71, 0xBF, 0x5D, 0xCC, 0x37, 0xE3, 0x97, 0x94, 0x31],
            bob_ephemeral_priv  : [0x78, 0xB4, 0x9B, 0x89, 0xC8, 0xFC, 0x12, 0x91, 0xDA, 0x22, 0x93, 0x95, 0x3F, 0xF3, 0xAA, 0x1B, 0x43, 0x0C, 0x8A, 0xEA, 0xF5, 0x07, 0x4D, 0xA5, 0xAF, 0x5F, 0x19, 0x3A, 0x70, 0x62, 0x8D, 0x5C],
            alice_send_ratchet_priv  : [0x70, 0x50, 0x96, 0xF5, 0x5E, 0xCC, 0x62, 0x5B, 0x37, 0xD6, 0x4B, 0x47, 0x60, 0xA6, 0x2C, 0x82, 0x78, 0xB9, 0x54, 0xD6, 0x6B, 0xB9, 0xEE, 0x25, 0x5A, 0xBB, 0x62, 0xB7, 0xB1, 0x58, 0x49, 0x7A],
            alice_send_ratchet_pub  : [0x05, 0xFE, 0x81, 0x4C, 0x0E, 0xE7, 0x17, 0x42, 0x1D, 0xDF, 0xDC, 0x75, 0xB6, 0xAC, 0xFE, 0x20, 0x2F, 0xE8, 0x5E, 0x91, 0x5C, 0x2B, 0xE2, 0x23, 0x4D, 0x0D, 0xC8, 0x39, 0x7B, 0x10, 0x3F, 0xE1, 0x1F],
            a2b_whispermsg  : vec![0x33, 0x0A, 0x21, 0x05, 0xFE, 0x81, 0x4C, 0x0E, 0xE7, 0x17, 0x42, 0x1D, 0xDF, 0xDC, 0x75, 0xB6, 0xAC, 0xFE, 0x20, 0x2F, 0xE8, 0x5E, 0x91, 0x5C, 0x2B, 0xE2, 0x23, 0x4D, 0x0D, 0xC8, 0x39, 0x7B, 0x10, 0x3F, 0xE1, 0x1F, 0x10, 0x00, 0x18, 0x00, 0x22, 0x20, 0x7E, 0xF6, 0xDA, 0x57, 0x96, 0xAC, 0x0D, 0x60, 0x2C, 0xEE, 0x33, 0xA7, 0x30, 0x4E, 0xB4, 0x5F, 0x0B, 0xD3, 0xC0, 0x03, 0x15, 0x8F, 0x76, 0x4F, 0x30, 0x9E, 0xFB, 0xE2, 0xCF, 0xE3, 0x2C, 0x5A, 0x20, 0x35, 0xF2, 0xF6, 0x9A, 0xAC, 0xF2, 0x71],
            known_plaintext : b"This is a plaintext message.".to_vec(),
        },
        TestCase{
             alice_id_pub  : [0x05, 0xA8, 0x05, 0xB4, 0x62, 0xFE, 0x66, 0x80, 0x3C, 0xDC, 0x7E, 0xF3, 0x14, 0x7A, 0x87, 0xDE, 0x5C, 0x69, 0x84, 0xDA, 0x34, 0x95, 0xA2, 0x96, 0x8E, 0xDE, 0x6F, 0x68, 0xDF, 0x01, 0x0A, 0xDF, 0x7B],
             alice_id_priv  : [0xA8, 0x66, 0xEF, 0x42, 0x0A, 0x39, 0x93, 0x57, 0xE5, 0x17, 0x0A, 0xE9, 0xCF, 0xB9, 0x86, 0x60, 0x8C, 0xA3, 0xDA, 0x0F, 0x86, 0x21, 0x65, 0x7F, 0x8A, 0x5A, 0x7E, 0x2B, 0x9A, 0xA9, 0x4A, 0x43],
             alice_base_pub  : [0x05, 0x9A, 0x81, 0xE4, 0x21, 0xB7, 0x14, 0x39, 0x8F, 0x58, 0xCE, 0x17, 0x66, 0xDD, 0x21, 0x5E, 0x82, 0xD2, 0x4A, 0x8C, 0xEF, 0xE7, 0x87, 0xDB, 0x1A, 0x67, 0x3A, 0x6E, 0x87, 0x8E, 0x02, 0xFA, 0x09],
             alice_base_priv  : [0x58, 0x47, 0x29, 0x97, 0x65, 0x28, 0x3C, 0xF8, 0x71, 0x01, 0x52, 0x78, 0x93, 0x21, 0x2B, 0xA0, 0x3C, 0x92, 0xC1, 0xD8, 0x1C, 0x6D, 0xBD, 0x07, 0x4F, 0x17, 0xFA, 0x00, 0x00, 0x8D, 0x71, 0x64],
             bob_id_pub  : [0x05, 0xE3, 0x75, 0xEF, 0x66, 0x39, 0xA6, 0x7F, 0xD2, 0xFA, 0x61, 0xE0, 0x42, 0x28, 0x4B, 0x6B, 0x48, 0x21, 0xBB, 0xAE, 0x4E, 0x1F, 0x61, 0x44, 0x35, 0x5F, 0x13, 0x16, 0x16, 0x31, 0x4A, 0xB0, 0x1B],
             bob_id_priv  : [0xF0, 0x40, 0x13, 0x26, 0xDB, 0x44, 0x27, 0x3F, 0x3B, 0x37, 0xC7, 0x9D, 0x78, 0xF3, 0x90, 0xC1, 0xC6, 0x89, 0xA3, 0xED, 0xE4, 0x9E, 0x4A, 0x71, 0xAB, 0xFA, 0xBA, 0x9C, 0xD3, 0x0F, 0x6B, 0x4D],
             bob_base_pub  : [0x05, 0xCF, 0x7F, 0xA3, 0xE7, 0xAC, 0x40, 0x39, 0x24, 0xE9, 0x65, 0x39, 0x6F, 0xFB, 0xB2, 0x66, 0xBE, 0x2C, 0x3E, 0xC0, 0x0D, 0x57, 0xAF, 0xAE, 0x4E, 0x92, 0x85, 0xC9, 0x98, 0xBC, 0x9C, 0x4B, 0x44],
             bob_base_priv  : [0xB0, 0x38, 0x30, 0xB0, 0x34, 0x7E, 0x1B, 0x1A, 0x8F, 0x99, 0xD2, 0xF1, 0x0A, 0xC9, 0x37, 0xE2, 0x2B, 0xE3, 0x4A, 0xF9, 0x08, 0x1F, 0xB7, 0xAF, 0x82, 0x09, 0xA2, 0x99, 0x75, 0x49, 0x0D, 0x40],
             bob_ephemeral_pub  : [0x05, 0xCF, 0x7F, 0xA3, 0xE7, 0xAC, 0x40, 0x39, 0x24, 0xE9, 0x65, 0x39, 0x6F, 0xFB, 0xB2, 0x66, 0xBE, 0x2C, 0x3E, 0xC0, 0x0D, 0x57, 0xAF, 0xAE, 0x4E, 0x92, 0x85, 0xC9, 0x98, 0xBC, 0x9C, 0x4B, 0x44],
             bob_ephemeral_priv  : [0xB0, 0x38, 0x30, 0xB0, 0x34, 0x7E, 0x1B, 0x1A, 0x8F, 0x99, 0xD2, 0xF1, 0x0A, 0xC9, 0x37, 0xE2, 0x2B, 0xE3, 0x4A, 0xF9, 0x08, 0x1F, 0xB7, 0xAF, 0x82, 0x09, 0xA2, 0x99, 0x75, 0x49, 0x0D, 0x40],
             alice_send_ratchet_priv  : [0x88, 0x25, 0x32, 0xDD, 0x5F, 0x21, 0xBB, 0x7C, 0x3B, 0x2C, 0x91, 0xAD, 0x7A, 0xE8, 0xDA, 0x72, 0x9D, 0x38, 0x8A, 0x55, 0xB3, 0xF5, 0x41, 0xB2, 0x8F, 0xCF, 0x98, 0x31, 0x53, 0xA5, 0xFB, 0x6D],
             alice_send_ratchet_pub  : [0x05, 0x19, 0x43, 0x62, 0xE1, 0x52, 0x86, 0x35, 0xA9, 0xCE, 0x50, 0x5E, 0x63, 0xF4, 0xFE, 0x49, 0xC1, 0xAC, 0xF0, 0x95, 0x25, 0x14, 0xD8, 0xDB, 0x57, 0xCD, 0x2C, 0x27, 0x2B, 0x2A, 0x41, 0x37, 0x72],
             a2b_whispermsg  : vec![0x33, 0x0A, 0x21, 0x05, 0x19, 0x43, 0x62, 0xE1, 0x52, 0x86, 0x35, 0xA9, 0xCE, 0x50, 0x5E, 0x63, 0xF4, 0xFE, 0x49, 0xC1, 0xAC, 0xF0, 0x95, 0x25, 0x14, 0xD8, 0xDB, 0x57, 0xCD, 0x2C, 0x27, 0x2B, 0x2A, 0x41, 0x37, 0x72, 0x10, 0x00, 0x18, 0x00, 0x22, 0x20, 0x1B, 0x31, 0xD7, 0xFB, 0x23, 0x55, 0x07, 0x58, 0x98, 0x4C, 0xFB, 0xF6, 0xDC, 0x4B, 0xFF, 0x72, 0xCA, 0x2B, 0x79, 0x18, 0x93, 0x66, 0x2D, 0x04, 0xFF, 0xC9, 0xE6, 0xA1, 0x0F, 0x0C, 0x23, 0xFC, 0xEC, 0x40, 0x6F, 0x27, 0x48, 0x3E, 0xAA, 0x76],
            known_plaintext : b"This is a plaintext message.".to_vec(),
        },
        TestCase{
             alice_id_pub  : [0x05, 0xEB, 0xFC, 0x2C, 0x8F, 0xFE, 0xD0, 0x1E, 0x60, 0xD6, 0x0A, 0x30, 0x1C, 0xF5, 0x10, 0x75, 0x43, 0x5F, 0xC7, 0xD0, 0x55, 0x2E, 0xD6, 0xAD, 0x14, 0x32, 0xE5, 0xEF, 0xC1, 0x81, 0x96, 0x0B, 0x0F],
             alice_id_priv  : [0x10, 0x3F, 0x34, 0x1F, 0xF8, 0x46, 0x9F, 0x71, 0x6E, 0x1A, 0x67, 0x14, 0x59, 0x1C, 0xFA, 0xDE, 0x82, 0x2A, 0x5A, 0xD9, 0x04, 0x06, 0x75, 0xA2, 0xC8, 0x37, 0x7A, 0xBF, 0xE4, 0x73, 0x63, 0x65],
             alice_base_pub  : [0x05, 0x39, 0xEE, 0x16, 0x39, 0xDD, 0xEB, 0x47, 0xC2, 0x1C, 0x08, 0x6F, 0x4B, 0x39, 0xFB, 0x77, 0x17, 0xB9, 0x67, 0x39, 0x2A, 0x72, 0x8C, 0xE6, 0x40, 0xA0, 0x35, 0xC2, 0xB7, 0x65, 0x89, 0x6D, 0x7D],
             alice_base_priv  : [0xC0, 0xA9, 0x10, 0xFC, 0x3F, 0x8A, 0x43, 0x2A, 0x7D, 0xA0, 0xBB, 0xEA, 0x1F, 0xD9, 0x33, 0x53, 0xFB, 0x90, 0x85, 0x4A, 0x29, 0xD5, 0x98, 0xA4, 0x4A, 0xA5, 0x18, 0xDC, 0x0F, 0xC9, 0xE1, 0x55],
             bob_id_pub  : [0x05, 0xEE, 0x63, 0x52, 0x44, 0x3E, 0x8F, 0x35, 0x10, 0x71, 0x76, 0x4D, 0x18, 0xB9, 0xAE, 0xC7, 0x0B, 0xBF, 0xF9, 0xED, 0x2E, 0xB8, 0x48, 0x1F, 0x1D, 0x9A, 0x4B, 0x69, 0xE9, 0x8D, 0x2E, 0xF1, 0x44],
             bob_id_priv  : [0xD0, 0x0C, 0x0A, 0x0F, 0xBD, 0x9B, 0xAD, 0xCA, 0x65, 0xB3, 0x3E, 0x52, 0x06, 0xDB, 0x2D, 0xC8, 0x99, 0x64, 0x55, 0xBE, 0xD0, 0x07, 0xA6, 0x48, 0xFF, 0x35, 0x01, 0x31, 0x5E, 0x3E, 0xB3, 0x5E],
             bob_base_pub  : [0x05, 0x5D, 0xE5, 0x40, 0x4B, 0x6A, 0x9D, 0x20, 0xF4, 0xDC, 0x28, 0xC6, 0xC2, 0xC3, 0x0C, 0x27, 0x19, 0x97, 0xF7, 0x7C, 0x9E, 0x6C, 0x39, 0x32, 0x4A, 0x84, 0xD1, 0xB6, 0xD8, 0xB6, 0xE3, 0x2D, 0x48],
             bob_base_priv  : [0x78, 0x73, 0x57, 0xFC, 0x1F, 0x4E, 0x73, 0x37, 0xAE, 0x38, 0x55, 0xF6, 0x3F, 0xB3, 0x88, 0x83, 0x3B, 0x45, 0x62, 0x9D, 0xDE, 0xB6, 0x02, 0x8E, 0xBC, 0x09, 0xA2, 0x37, 0xCC, 0x96, 0xDB, 0x5D],
             bob_ephemeral_pub  : [0x05, 0x5D, 0xE5, 0x40, 0x4B, 0x6A, 0x9D, 0x20, 0xF4, 0xDC, 0x28, 0xC6, 0xC2, 0xC3, 0x0C, 0x27, 0x19, 0x97, 0xF7, 0x7C, 0x9E, 0x6C, 0x39, 0x32, 0x4A, 0x84, 0xD1, 0xB6, 0xD8, 0xB6, 0xE3, 0x2D, 0x48],
             bob_ephemeral_priv  : [0x78, 0x73, 0x57, 0xFC, 0x1F, 0x4E, 0x73, 0x37, 0xAE, 0x38, 0x55, 0xF6, 0x3F, 0xB3, 0x88, 0x83, 0x3B, 0x45, 0x62, 0x9D, 0xDE, 0xB6, 0x02, 0x8E, 0xBC, 0x09, 0xA2, 0x37, 0xCC, 0x96, 0xDB, 0x5D],
             alice_send_ratchet_priv  : [0x60, 0xF6, 0x03, 0xF9, 0xCA, 0x81, 0x5F, 0x5A, 0x02, 0xA8, 0x73, 0xB7, 0xF6, 0xB1, 0x59, 0x8C, 0x19, 0xD0, 0x28, 0x71, 0x6C, 0xB2, 0x85, 0x9A, 0x4A, 0x7F, 0xF9, 0x20, 0x06, 0xE5, 0xF8, 0x51],
             alice_send_ratchet_pub  : [0x05, 0x36, 0xA7, 0x6C, 0x17, 0xCB, 0x77, 0x1C, 0xB6, 0x96, 0x4F, 0x19, 0xC2, 0xD2, 0x93, 0xA6, 0x58, 0x36, 0x7F, 0x90, 0x9A, 0xBA, 0x9F, 0x0A, 0x85, 0x4E, 0x55, 0x9B, 0x3F, 0xFC, 0x7E, 0xBD, 0x57],
             a2b_whispermsg  : vec![0x33, 0x0A, 0x21, 0x05, 0x36, 0xA7, 0x6C, 0x17, 0xCB, 0x77, 0x1C, 0xB6, 0x96, 0x4F, 0x19, 0xC2, 0xD2, 0x93, 0xA6, 0x58, 0x36, 0x7F, 0x90, 0x9A, 0xBA, 0x9F, 0x0A, 0x85, 0x4E, 0x55, 0x9B, 0x3F, 0xFC, 0x7E, 0xBD, 0x57, 0x10, 0x00, 0x18, 0x00, 0x22, 0x20, 0x2F, 0x08, 0x00, 0x75, 0xE5, 0x20, 0xD9, 0x18, 0xBA, 0x57, 0x9B, 0x31, 0xDF, 0x5A, 0x0C, 0x78, 0xF0, 0xCA, 0xF3, 0xA2, 0xD9, 0xF7, 0xFE, 0x60, 0xA6, 0xB0, 0x62, 0xAE, 0x48, 0xD7, 0xFA, 0x1A, 0xB5, 0xE3, 0x14, 0xA5, 0x26, 0x3C, 0xB8, 0xC1],
             known_plaintext : b"This is a plaintext message.".to_vec(),
        },
    ]
}

#[test]
fn libaxolotl_java_interop_send(){
    let ref axolotl_impl = TextSecureV3;
    // let test_vector = &interop_tests()[0];
    for test_vector in interop_tests() {
        let (ref mut alice, ref mut __) = init_states_from_testcase(&test_vector);
        let packet_bytes_vec = encrypt_and_serialze(axolotl_impl,alice,PlainText(test_vector.known_plaintext.to_vec()));

        assert_eq!(&packet_bytes_vec[..],&test_vector.a2b_whispermsg[..]);
    }

}
#[test]
fn libaxolotl_java_interop_receive(){  
    let ref axolotl_impl = TextSecureV3;  
    for test_vector in interop_tests() {
        let (ref __, ref mut bob) = init_states_from_testcase(&test_vector);

        let plaintext = match deserialize_and_decrypt(axolotl_impl, bob, &test_vector.a2b_whispermsg[..]){
            Ok(p) => p,
            Err(e) => {println!("{:?}", e ); panic!();},
        };

        assert_eq!(plaintext.0, &test_vector.known_plaintext[..]);
    }
}

// ------ Utitlities ------
fn dhkey_pair() -> KeyPair<TextSecureV3> {
    let priv_key  = curve25519::generate_private_key();
    let pub_key = curve25519::derive_public_key(&priv_key);

    KeyPair{ key :priv_key, public : pub_key}
} 

fn dhkey_pair_from_bytes(private : [u8;32], public: [u8;33]) -> KeyPair<TextSecureV3> {

    KeyPair{ key :curve25519::PrivateKey::from_bytes(private), public : curve25519::PublicKey::from_bytes(public)}
}

fn triple_dh_shared_secret_and_identity(
  alice_identity : KeyPair<TextSecureV3>,
  alice_handshake : KeyPair<TextSecureV3>,
  bob_identity : KeyPair<TextSecureV3>,
  bob_handshake : KeyPair<TextSecureV3>,
) -> (Vec<u8>, Vec<u8>) {

  let session_identity = [&alice_identity.public.to_bytes()[..], &bob_identity.public.to_bytes()[..]].concat();

  let alice_shared_secret = [
      &curve25519::derive_shared_key(&alice_identity.key, &bob_handshake.public).to_bytes()[..],
      &curve25519::derive_shared_key(&alice_handshake.key, &bob_identity.public).to_bytes()[..],
      &curve25519::derive_shared_key(&alice_handshake.key, &bob_handshake.public).to_bytes()[..],
    ].concat();

    let bob_shared_secret = [
      &curve25519::derive_shared_key(&bob_handshake.key, &alice_identity.public).to_bytes()[..],
      &curve25519::derive_shared_key(&bob_identity.key, &alice_handshake.public).to_bytes()[..],
      &curve25519::derive_shared_key(&bob_handshake.key, &alice_handshake.public).to_bytes()[..],
    ].concat();

    assert!(alice_shared_secret == bob_shared_secret);

    (alice_shared_secret, session_identity)
}

fn init_dynamic_axolotl_states(axolotl_impl : &TextSecureV3) -> (axolotl::AxolotlState<TextSecureV3>, axolotl::AxolotlState<TextSecureV3>) {

    let alice_identity = dhkey_pair();
    let alice_handshake = dhkey_pair();
    let bob_identity = dhkey_pair();
    let bob_handshake = dhkey_pair();
    let initial_ratchet = dhkey_pair();

    let (shared_secret, session_identity) = triple_dh_shared_secret_and_identity(
      alice_identity, 
      alice_handshake,
      bob_identity,
      bob_handshake,
    );

    let alice = axolotl::init_as_alice::<TextSecureV3>(
      axolotl_impl,
      session_identity.clone(),
      shared_secret.clone(),
      initial_ratchet.public.clone(),
    );
    let bob = axolotl::init_as_bob::<TextSecureV3>(
      axolotl_impl, 
      session_identity.clone(),
      shared_secret.clone(),
      initial_ratchet
    );
    (alice,bob)
}

fn init_states_from_testcase(test_vector : &TestCase) -> (axolotl::AxolotlState<TextSecureV3>,axolotl::AxolotlState<TextSecureV3>) {
    let alice_identity_keypair  = dhkey_pair_from_bytes(test_vector.alice_id_priv,test_vector.alice_id_pub);
    let bob_identity_keypair    = dhkey_pair_from_bytes(test_vector.bob_id_priv,test_vector.bob_id_pub);
    
    let alice_base_keypair      = dhkey_pair_from_bytes(test_vector.alice_base_priv,test_vector.alice_base_pub);
    let bob_base_keypair        = dhkey_pair_from_bytes(test_vector.bob_base_priv,test_vector.bob_base_pub);

    let alice_ratchet_keypair   = dhkey_pair_from_bytes(test_vector.alice_send_ratchet_priv, test_vector.alice_send_ratchet_pub);
    let bob_ephemeral_keypair   = dhkey_pair_from_bytes(test_vector.bob_ephemeral_priv,test_vector.bob_ephemeral_pub);

    let alice = init_alice(
        &TextSecureV3,
        alice_identity_keypair,
        alice_base_keypair,
        alice_ratchet_keypair,
        <whisper_protocol::text_secure_v3::TextSecureV3 as axolotl::Axolotl>::PublicKey::from_bytes(test_vector.bob_id_pub),
        <whisper_protocol::text_secure_v3::TextSecureV3 as axolotl::Axolotl>::PublicKey::from_bytes(test_vector.bob_ephemeral_pub),
        <whisper_protocol::text_secure_v3::TextSecureV3 as axolotl::Axolotl>::PublicKey::from_bytes(test_vector.bob_base_pub),
    );

    let bob = init_bob(
        &TextSecureV3,
        bob_identity_keypair.clone(),
        bob_ephemeral_keypair.clone(),
        bob_base_keypair.clone(),
        <whisper_protocol::text_secure_v3::TextSecureV3 as axolotl::Axolotl>::PublicKey::from_bytes(test_vector.alice_id_pub),
        <whisper_protocol::text_secure_v3::TextSecureV3 as axolotl::Axolotl>::PublicKey::from_bytes(test_vector.alice_base_pub),
    );

    (alice,bob)
}

fn init_alice(
    axolotl_impl : &TextSecureV3,
    our_id_keypair : KeyPair<TextSecureV3>,
    our_base_keypair : KeyPair<TextSecureV3>,
    our_ratchet_keypair: KeyPair<TextSecureV3>,
    their_id_key : PublicKey,
    their_ratchet_key : PublicKey,
    their_signed_prekey : PublicKey
)-> axolotl::AxolotlState<TextSecureV3>{
    let session_identity = [&our_id_keypair.public.to_bytes()[..],&their_id_key.to_bytes()[..]].concat();

    let shared_secret = [
        &curve25519::derive_shared_key(&our_id_keypair.key, &their_ratchet_key).to_bytes()[..],
        &curve25519::derive_shared_key(&our_base_keypair.key, &their_id_key).to_bytes()[..],
        &curve25519::derive_shared_key(&our_base_keypair.key, &their_ratchet_key).to_bytes()[..],
    ].concat();
    
    axolotl::init_as_alice_with_explicit_ratchet_keypair::<TextSecureV3>(
        axolotl_impl,
        session_identity.clone(),
        shared_secret.clone(),
        our_ratchet_keypair.clone(),
        their_signed_prekey.clone(),
    )
}

fn init_bob(
    axolotl_impl : &TextSecureV3,
    our_id_keypair : KeyPair<TextSecureV3>,
    our_ratchet_keypair : KeyPair<TextSecureV3>,
    our_signed_prekey : KeyPair<TextSecureV3>,
    their_id_key : PublicKey,
    their_base_key : PublicKey,

)-> axolotl::AxolotlState<TextSecureV3>{
    let session_identity = [&their_id_key.to_bytes()[..], &our_id_keypair.public.to_bytes()[..] ].concat();

    let shared_secret = [
        &curve25519::derive_shared_key(&our_ratchet_keypair.key, &their_id_key).to_bytes()[..],
        &curve25519::derive_shared_key(&our_id_keypair.key, &their_base_key).to_bytes()[..],
        &curve25519::derive_shared_key(&our_ratchet_keypair.key, &their_base_key).to_bytes()[..],
    ].concat();

    axolotl::init_as_bob::<TextSecureV3>(
        axolotl_impl,
        session_identity.clone(),
        shared_secret.clone(),
        our_signed_prekey.clone(),
    )
}

pub fn encrypt_and_serialze(
    axolotl_impl : &TextSecureV3,
    state : &mut AxolotlState<TextSecureV3>,
    msg : PlainText
) -> Vec<u8>{
    let (packet,mac) = state.encrypt(axolotl_impl, msg).unwrap();
    let mut packet = packet;
    packet.set_mac(mac);
    packet.to_vec()
}

pub fn deserialize_and_decrypt(axolotl_impl : &TextSecureV3 ,state : &mut AxolotlState<TextSecureV3>, bytes : &[u8]) -> Result<PlainText, ReceiveError<TextSecureV3> >{
    let mut packet = TransportPacket::from_bytes(bytes).ok().unwrap();
    let mac = packet.take_mac().unwrap();
    state.decrypt(axolotl_impl, packet,mac)
}
